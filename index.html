<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Threadweaver</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap');
        body {
            font-family: 'Inter', sans-serif;
            background-color: #0d1117;
            color: #c9d1d9;
        }

        /* Container for the editor and visual editor */
        .editor-container {
            position: relative;
        }

        /* The textarea is transparent to show the visual editor underneath */
        .editor-container textarea {
            position: relative;
            z-index: 10;
            resize: none;
            color: transparent; /* Makes text invisible in textarea */
            caret-color: #c9d1d9; /* Keeps cursor visible */
            overflow: hidden; /* Hides the scrollbar */
            /* Sync padding for perfect cursor alignment */
            padding: 1rem;
            padding-left: 2.5rem;
            /* Create a clip path to exclude the prefix area from mouse events */
            clip-path: inset(0 0 0 2.5rem);
        }

        /* The visual-editor div sits behind the textarea */
        .editor-container #visual-editor {
            position: absolute;
            top: 0;
            left: 0;
            white-space: pre-wrap;
            word-wrap: break-word;
            border-radius: 0.5rem;
            background-color: #161b22;
            pointer-events: none; /* Allows mouse events to pass through to the textarea */
            /* Sync padding for perfect cursor alignment */
            padding: 1rem;
            padding-left: 2.5rem;
        }

        /* Styles for the post prefix */
        .post-prefix {
            position: absolute;
            left: 0.5rem;
            font-weight: bold;
            color: #4b5563; /* Subtle gray color */
            font-weight: bold;
            cursor: pointer;
            pointer-events: auto;
        }

        /* Styles for the overage text highlighting */
        .highlight-overage {
            color: #f87171; /* Red color for overage characters */
        }
    </style>
</head>
<body class="p-6 md:p-10 flex flex-col items-center min-h-screen">

    <!-- Main Content Container -->
    <div class="w-full max-w-5xl">
        <h1 class="text-3xl font-bold mb-4 text-center">Threadweaver</h1>
        <p class="text-sm text-gray-400 text-center mb-6">Write your post below. Use three blank lines to create a new post chunk. Characters over the limit will be highlighted in red.</p>
        
        <!-- Main Editor Area -->
        <div class="w-full bg-slate-800 rounded-lg shadow-lg p-6 mb-8">
            <div class="flex justify-between items-center mb-2">
                <span id="char-counter" class="text-sm font-semibold text-gray-400">0/300</span>
                <span id="chunk-info" class="text-sm text-gray-500">Chunk 1 of 1</span>
            </div>

            <!-- Editor Container with Visual Editor -->
            <div class="editor-container min-h-[15rem]">
                <textarea id="post-editor" class="w-full h-full bg-transparent text-lg border border-slate-700 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500" placeholder="Start writing your post here..."></textarea>
                <div id="visual-editor" class="w-full h-full text-lg"></div>
            </div>

            <div class="flex justify-end mt-4">
                <button id="copy-button" class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-6 rounded-lg shadow-md transition-all duration-200 ease-in-out focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2 focus:ring-offset-slate-800 disabled:opacity-50 disabled:cursor-not-allowed">
                    Copy All Posts
                </button>
            </div>
        </div>
    </div>

    <script>
        const editor = document.getElementById('post-editor');
        const visualEditor = document.getElementById('visual-editor');
        const charCounter = document.getElementById('char-counter');
        const chunkInfo = document.getElementById('chunk-info');
        const copyButton = document.getElementById('copy-button');

        const CHARACTER_LIMIT = 300;

        // Regex patterns for URL and mention detection
        const urlRegex = /(https?:\/\/[^\s]+)/g;
        const mentionRegex = /(@[a-zA-Z0-9.]+)/g;

        /**
         * Handles clicking on a post prefix
         * @param {number} chunkNumber - The chunk number that was clicked
         */
        function handlePrefixClick(chunkNumber) {
            console.log(`Clicked on prefix for chunk ${chunkNumber}`);
        }
        
        /**
         * Checks a single chunk of text for its character count and overage, and provides formatting details.
         * This function now uses the correct BlueSky character counting algorithm.
         * @param {string} chunk - The text chunk to check.
         * @returns {{length: number, isOverage: boolean, safeText: string, overageText: string}} - Details of the chunk.
         */
        function getChunkDetails(chunk) {
            let length = 0;
            const textParts = [];
            let lastIndex = 0;
            
            // Combine all matches into a single sorted array
            const matches = [
                ...Array.from(chunk.matchAll(urlRegex), m => ({ text: m[0], type: 'url', index: m.index })),
                ...Array.from(chunk.matchAll(mentionRegex), m => ({ text: m[0], type: 'mention', index: m.index }))
            ].sort((a, b) => a.index - b.index);

            matches.forEach(match => {
                // Add regular text before the match
                if (match.index > lastIndex) {
                    const text = chunk.substring(lastIndex, match.index);
                    length += text.length;
                    textParts.push({ text: text, type: 'text' });
                }

                // Add the special link/mention
                const specialLength = match.type === 'url' ? 20 : 15;
                length += specialLength;
                textParts.push({ text: match.text, type: match.type });
                
                lastIndex = match.index + match.text.length;
            });
            
            // Add any remaining text after the last match
            if (lastIndex < chunk.length) {
                const text = chunk.substring(lastIndex);
                length += text.length;
                textParts.push({ text: text, type: 'text' });
            }

            const isOverage = length > CHARACTER_LIMIT;

            // Reconstruct the safe and overage text for highlighting
            let currentLength = 0;
            let safeText = '';
            let overageText = '';
            textParts.forEach(part => {
                const partLength = part.type === 'url' ? 20 : (part.type === 'mention' ? 15 : part.text.length);
                
                if (currentLength + partLength <= CHARACTER_LIMIT) {
                    safeText += part.text;
                    currentLength += partLength;
                } else {
                    const remainingLength = CHARACTER_LIMIT - currentLength;
                    const safeChars = part.text.length > remainingLength ? part.text.substring(0, remainingLength) : part.text;
                    safeText += safeChars;
                    overageText += part.text.substring(safeChars.length);
                    currentLength += safeChars.length;
                }
            });
            
            return { length, isOverage, safeText, overageText };
        }


        // Load content from localStorage on page load
        document.addEventListener('DOMContentLoaded', () => {
            const savedContent = localStorage.getItem('bluesky-post-content');
            if (savedContent) {
                editor.value = savedContent;
                updateContent();
            }
        });

        // Event listeners for editor input, click, and keyup to ensure UI is always in sync with cursor position
        editor.addEventListener('input', () => {
            localStorage.setItem('bluesky-post-content', editor.value);
            updateContent();
        });
        editor.addEventListener('click', updateContent);
        editor.addEventListener('keyup', updateContent);

        copyButton.addEventListener('click', () => {
            const text = editor.value;
            const chunks = text.split(/\n\n\n/);
            
            if (chunks.length === 0 || editor.value.trim() === '') {
                return;
            }

            const postsToCopy = chunks.map((chunk, index) => `${index + 1}/ ${chunk}`);
            const fullText = postsToCopy.join('\n\n');
            
            // Create a temporary textarea to hold the text
            const tempTextArea = document.createElement('textarea');
            tempTextArea.value = fullText;
            document.body.appendChild(tempTextArea);
            tempTextArea.select();
            
            try {
                document.execCommand('copy');
                const originalText = copyButton.textContent;
                copyButton.textContent = 'Copied!';
                copyButton.disabled = true;
                setTimeout(() => {
                    copyButton.textContent = originalText;
                    copyButton.disabled = false;
                }, 1500);
            } catch (err) {
                console.error('Failed to copy text:', err);
            } finally {
                document.body.removeChild(tempTextArea);
            }
        });

        function updateContent() {
            const text = editor.value;
            const chunks = text.split(/\n\n\n/);
            let currentChunkIndex = 0;
            const editorScrollTop = editor.scrollTop;

            // Find the current chunk based on cursor position
            const cursorPosition = editor.selectionStart;
            let charCountBeforeCursor = 0;
            for (let i = 0; i < chunks.length; i++) {
                const chunkLength = chunks[i].length + (i === chunks.length - 1 ? 0 : 3);
                if (charCountBeforeCursor + chunkLength >= cursorPosition) {
                    currentChunkIndex = i;
                    break;
                }
                charCountBeforeCursor += chunkLength;
            }

            // Update the visual editor
            let newVisualEditorHTML = '';
            chunks.forEach((chunk, index) => {
                const postPrefix = `${index + 1}/ `;
                if (index > 0) {
                    newVisualEditorHTML += '<br><br><br>'; // Add back the blank lines
                }
                const chunkDetails = getChunkDetails(chunk);
                if (chunkDetails.isOverage) {
                    newVisualEditorHTML += `<span class="post-prefix">${postPrefix}</span><span>${chunkDetails.safeText}</span><span class="highlight-overage">${chunkDetails.overageText}</span>`;
                } else {
                    newVisualEditorHTML += `<span class="post-prefix">${postPrefix}</span><span>${chunk}</span>`;
                }
            });
            visualEditor.innerHTML = newVisualEditorHTML;

            // Add click event listeners to all prefix elements
            const prefixElements = visualEditor.querySelectorAll('.post-prefix');
            prefixElements.forEach((prefixElement, index) => {
                prefixElement.addEventListener('click', () => handlePrefixClick(index + 1));
            });

            // Sync scroll positions
            visualEditor.scrollTop = editorScrollTop;
            
            // Auto-resize the editor and visual editor to fit content
            editor.style.height = 'auto';
            const newHeight = editor.scrollHeight;
            editor.style.height = newHeight + 'px';
            visualEditor.style.height = newHeight + 'px';

            // Update the chunk information and character counter
            chunkInfo.textContent = `Chunk ${currentChunkIndex + 1} of ${chunks.length}`;
            const currentChunkText = chunks[currentChunkIndex] || '';
            const currentChunkDetails = getChunkDetails(currentChunkText);
            charCounter.textContent = `${currentChunkDetails.length}/${CHARACTER_LIMIT}`;
            if (currentChunkDetails.isOverage) {
                charCounter.classList.add('text-red-400');
                charCounter.classList.remove('text-gray-400');
            } else {
                charCounter.classList.remove('text-red-400');
                charCounter.classList.add('text-gray-400');
            }
            
            copyButton.disabled = editor.value.trim() === '';
        }
    </script>
</body>
</html>
